<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>5. Async Await</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .container { max-width: 600px; margin: auto; padding: 20px; border: 1px solid lightgray; border-radius: 8px; }
        button { padding: 10px 15px; font-size: 16px; cursor: pointer; margin: 5px; }
        #log { margin-top: 20px; padding: 10px; border: 1px solid black; background-color: ghostwhite; min-height: 150px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>5. Async/Await로 비동기 코드 동기처럼 작성하기</h1>
        <p>Promise 기반 코드를 가장 깔끔하고 직관적으로 만드는 방법을 확인하세요.</p>
        <button id="start-btn">작업 시작 (성공)</button>
        <button id="fail-btn">작업 시작 (실패)</button>
        <div id="log"></div>
    </div>
    
    <script>
        const startBtn = document.getElementById('start-btn');
        const failBtn = document.getElementById('fail-btn');
        const logDiv = document.getElementById('log');

        const log = (message, isError = false) => {
            logDiv.innerHTML += `<div style="color: ${isError ? 'red' : 'black'};">${message}</div>`;
        };

        /*
        ==================================================================================
        🎯 Async / Await 이란?
        ==================================================================================
        - Promise를 더 쉽게 사용하기 위한 '문법적 설탕(Syntactic Sugar)'입니다.
        - async: 함수 앞에 붙이면 해당 함수는 항상 Promise를 반환합니다.
        - await: async 함수 안에서만 사용 가능하며, Promise가 완료될 때까지 코드 실행을 '기다립니다'.
                완료되면 Promise의 결과값을 반환합니다.
        - 장점: 비동기 코드를 동기 코드처럼 순차적으로 작성할 수 있어 가독성이 매우 향상됩니다.
        - 에러 처리: Promise의 .catch() 대신, 동기 코드에서와 동일한 try...catch 구문을 사용합니다.
        */

        // Promise를 반환하는 기본 비동기 함수 (이전 예제와 동일)
        function asyncTask(taskName, duration, shouldSucceed) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (shouldSucceed) {
                        log(`✅ '${taskName}' 완료`);
                        resolve(taskName);
                    } else {
                        log(`❌ '${taskName}' 실패`);
                        reject(new Error(`'${taskName}'에서 문제 발생`));
                    }
                }, duration);
            });
        }

        // async/await를 사용한 비동기 작업 흐름 제어
        async function runProcess(shouldFail) {
            log('🚀 작업 프로세스를 시작합니다...');
            try {
                // await: asyncTask가 resolve될 때까지 여기서 기다립니다.
                const result1 = await asyncTask('1. 사용자 인증', 1000, true);
                log(`- 중간 결과 1: ${result1}`);

                // 중간에 실패를 주입할지 결정
                const step2Success = !shouldFail;
                const result2 = await asyncTask('2. 데이터 로드', 1000, step2Success);
                log(`- 중간 결과 2: ${result2}`);

                const result3 = await asyncTask('3. 결과 화면 렌더링', 1000, true);
                log(`- 중간 결과 3: ${result3}`);

                log('🎉 모든 작업이 성공적으로 완료되었습니다.');

            } catch (error) {
                // await 하던 Promise 중 하나라도 reject되면, 즉시 catch 블록이 실행됩니다.
                log(`❗️ 에러 발생! 프로세스 중단: ${error.message}`, true);
            } finally {
                // 성공하든 실패하든 마지막에 항상 실행됩니다.
                log('🏁 작업 프로세스를 종료합니다.');
            }
        }

        startBtn.addEventListener('click', () => {
            logDiv.innerHTML = '';
            runProcess(false); // 실패 없이 실행
        });
        
        failBtn.addEventListener('click', () => {
            logDiv.innerHTML = '';
            runProcess(true); // 중간에 실패하도록 실행
        });

    </script>
</body>
</html>